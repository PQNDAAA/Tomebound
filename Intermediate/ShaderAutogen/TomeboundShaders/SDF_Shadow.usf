    return 1;
}

#include "/Engine/Private/DistanceField/GlobalDistanceFieldShared.ush"
#include "/Engine/Private/SceneTexturesCommon.ush"

float interleaved_gradient_noise(float2 screenPos, int frame)
{
    screenPos += frame ;//+ View.GameTime / 60.0; // temporal factor
    float3 magic = float3(0.06711056f, 0.00583715f, 52.9829189f);
    return frac(magic.z * frac(dot(screenPos, magic.xy)));
}

float4 WorldToClip(float3 WorldPosition)
{
    float4 ScreenPos = mul(float4(WorldPosition.xyz + LWCHackToFloat(PrimaryView.PreViewTranslation), 1),	PrimaryView.TranslatedWorldToClip);
    return ScreenPos;
}

float4 WorldToView(float3 WorldPosition)
{
    float4 ScreenPos = mul(float4(WorldPosition.xyz + LWCHackToFloat(PrimaryView.PreViewTranslation), 1),	PrimaryView.TranslatedWorldToView);
    return ScreenPos;
}

float2 WorldToScreenUV(float3 worldPos) {
    float4 clipPos = WorldToClip(worldPos);
    float2 pixelCoord = clipPos.xy;
    pixelCoord /= clipPos.w;
    pixelCoord = pixelCoord * PrimaryView.ScreenPositionScaleBias.xy + PrimaryView.ScreenPositionScaleBias.wz;
    return pixelCoord;
}


#define SDF_SHADOW_STEPS 64
#define SS_SHADOW_STEPS 6
#define SS_SHADOW_RAYS 6
float screenSpaceShadowRay(float3 pos, float3 dir, float penumbra, float firstStep, int maxSteps, float maxRayLength, float2 screenPos, int frame) {
    float step = maxRayLength / SS_SHADOW_STEPS;
    firstStep = step * (1.0* interleaved_gradient_noise(screenPos, frame) + 0.1) ;
    float dist = penumbra;
    float3 offset = dir * firstStep ;
    float3 rayPos = pos + offset;
    float depthDiff;
    float2 uv;
    float rayLength = firstStep;
    float shade = 1.0;
    for(int i = 0; i < SS_SHADOW_STEPS; i++){
        dist = GetDistanceToNearestSurfaceGlobal(rayPos + LWCHackToFloat(PrimaryView.PreViewTranslation));
        rayLength += step;
        if(rayLength < maxRayLength) {
            uv = WorldToScreenUV(rayPos);
            depthDiff = WorldToView(rayPos).z - SceneTextureLookup(uv, 1, false).x;
            if(depthDiff > 0.0 && (dist < penumbra || depthDiff < penumbra)) {
                shade = 0.;//min(dist,depthDiff) / penumbra;
                break;
            }
            rayPos += dir * step;
        }
    }

    return shade;
}

float screenSpaceShadow(float3 pos, float3 dir, float penumbra, float firstStep, int maxSteps, float maxRayLength, float2 screenPos) {
    float shade = 0.0;
    int frame = View.FrameNumber * SS_SHADOW_RAYS;
    for(int i = 0; i < SS_SHADOW_RAYS; i++) {
        shade += screenSpaceShadowRay(pos, dir, penumbra, firstStep, maxSteps, maxRayLength, screenPos, frame);
        frame += Mod(SS_SHADOW_RAYS /2 + 1, SS_SHADOW_RAYS) ;
    }
    return shade / float(SS_SHADOW_RAYS);
}


float sdfShadow(float3 pos, float3 dir, float penumbra, float firstStep, int maxSteps, float maxRayLength, float2 screenPos) {
    float noise = interleaved_gradient_noise(screenPos,View.FrameNumber * SS_SHADOW_RAYS);
    float3 rayPos = pos + firstStep * dir * (1.0 + 0.8 * noise);
    float shade = 0.;
    float minDist = penumbra;
    float dist = firstStep;
    float rayLength = firstStep;
    for(int i=0; i<SDF_SHADOW_STEPS && i<maxSteps; i++){
        dist = GetDistanceToNearestSurfaceGlobal(rayPos);
        rayLength += dist;
        if(rayLength < maxRayLength) {
            minDist = min(minDist, dist);
            rayPos += dir * dist;
        }
    }
    shade = minDist;
    return shade;

