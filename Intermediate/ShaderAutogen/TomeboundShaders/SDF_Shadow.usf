    return 1;
}

#include "/Engine/Private/DistanceField/GlobalDistanceFieldShared.ush"
#include "/Engine/Private/SceneTexturesCommon.ush"

float interleaved_gradient_noise(float2 screenPos)
{
    screenPos += View.FrameNumber; // temporal factor
    float3 magic = float3(0.06711056f, 0.00583715f, 52.9829189f);
    return frac(magic.z * frac(dot(screenPos, magic.xy)));
}

float4 WorldToClip(float3 WorldPosition)
{
    float4 ScreenPos = mul(float4(WorldPosition.xyz + LWCHackToFloat(PrimaryView.PreViewTranslation), 1),	PrimaryView.TranslatedWorldToClip);
    return ScreenPos;
}

float4 WorldToView(float3 WorldPosition)
{
    float4 ScreenPos = mul(float4(WorldPosition.xyz + LWCHackToFloat(PrimaryView.PreViewTranslation), 1),	PrimaryView.TranslatedWorldToView);
    return ScreenPos;
}

float2 WorldToScreenUV(float3 worldPos) {
    float4 clipPos = WorldToClip(worldPos);
    float2 pixelCoord = clipPos.xy;
    pixelCoord /= clipPos.w;
    pixelCoord = pixelCoord * PrimaryView.ScreenPositionScaleBias.xy + PrimaryView.ScreenPositionScaleBias.wz;
    return pixelCoord;
}


#define SDF_SHADOW_STEPS 64
#define SS_SHADOW_STEPS 64

float screenSpaceShadow(float3 pos, float3 dir, float penumbra, float firstStep, int maxSteps, float maxRayLength, float2 screenPos) {
    float step = maxRayLength / maxSteps;
    firstStep = step * interleaved_gradient_noise(screenPos);
    float dist = penumbra;
    float3 offset = dir * firstStep ;
    float3 rayPos = pos + offset;
    float depthDiff;
    float2 uv;
    float rayLength = firstStep;
    float shade = 1.0;
    for(int i = 0; i < SS_SHADOW_STEPS && i < maxSteps; i++){
        dist = GetDistanceToNearestSurfaceGlobal(rayPos + LWCHackToFloat(PrimaryView.PreViewTranslation));
        rayLength += step;
        if(rayLength < maxRayLength) {
            uv = WorldToScreenUV(rayPos);
            depthDiff = WorldToView(rayPos).z - SceneTextureLookup(uv, 1, false).x;
            if(depthDiff > 0.0 && (dist < penumbra || depthDiff < penumbra)) {
                shade = 0.;
                break;
            }
            rayPos += dir * step;
        }
    }

    return shade;
}

float sdfShadow(float3 pos, float3 dir, float penumbra, float firstStep, int maxSteps, float maxRayLength, float2 screenPos) {
    float noise = interleaved_gradient_noise(screenPos);
    float3 rayPos = pos + firstStep * dir * (1.0 + 0.8 * noise);
    float shade = 0.;
    float minDist = penumbra;
    float dist = firstStep;
    float rayLength = firstStep;
    for(int i=0; i<SDF_SHADOW_STEPS && i<maxSteps; i++){
        dist = GetDistanceToNearestSurfaceGlobal(rayPos);
        rayLength += dist;
        if(rayLength < maxRayLength) {
            minDist = min(minDist, dist);
            rayPos += dir * dist;
        }
    }
    shade = minDist;
    return shade;

